/****************************************************************************
 * This file is a part of gEcon.                                             
 *                                                                           
 * (c) Chancellery of the Prime Minister of the Republic of Poland 2012-2015 
 * (c) Grzegorz Klima, Karol Podemski, Kaja Retkiewicz-Wijtiwiak 2015-2016   
 * License terms can be found in the file 'LICENCE'                          
 *                                                                           
 * Author: Grzegorz Klima                                                    
 ***************************************************************************/

/** \file model_parse.cpp
 * \brief Parsing the model.
 */

#include <model_parse.h>
#include <stdexcept>
#include <vector>
#include <string>
#ifdef R_DLL
#include <R.h>
#include <Rcpp.h>
#endif /* R_DLL */
#include <utils.h>
#include <gecon_info.h>
#include <gecon_tokens.h>
#include "gEconLexer.hpp"
#include "gEconParser.hpp"

unsigned char **tnames;

using namespace parser;

std::vector<std::string> errors;
Model model_obj;


void
report_errors(const std::string &mes)
{
#ifdef R_DLL
    Rf_error(('\n' + mes).c_str());
#else /* R_DLL */
    std::cerr << "errors:\n" << mes << '\n';
    exit(1);
#endif /* R_DLL */
}


void
report_warns(const std::string &mes)
{
#ifdef R_DLL
    warning(('\n' + mes).c_str());
#else /* R_DLL */
    std::cerr << "warnings:\n" << mes << '\n';
#endif /* R_DLL */
}


void
write_info(const std::string &mes)
{
#ifdef R_DLL
    Rprintf((mes + '\n').c_str());
#else /* R_DLL */
    std::cerr << mes << '\n';
#endif /* R_DLL */
}


#ifdef R_DLL
RcppExport
SEXP
parse_from_R(SEXP inputname)
{
    std::string name = Rcpp::as<std::string>(inputname);
    model_parse(name.c_str());
    return Rcpp::wrap(true);
}
#endif /* R_DLL */



std::string
get_mod_name(const std::string &s)
{
    unsigned l = s.size();
    if ((l < 5) || (s[l-1] != 'n') || (s[l-2] != 'c')
        || (s[l-3] != 'g') || (s[l-4] != '.')) return std::string();
    std::string ret = s;
    ret.erase(l - 4, l - 1);
    return ret;
}


void
model_parse(const char *fname)
{
    unsigned char **tnames = mk_tnames();
    model_obj.clear();
    std::string name(fname), mod_name;

    // write_info(gecon_hello_str());
    mod_name = get_mod_name(name);
    if (!mod_name.size()) {
        report_errors("(gEcon error): invalid model file name or extension: \'" + name + "\'");
    }
    model_obj.set_name(mod_name);

    ANTLR_UINT8 *fName;
    fName = (ANTLR_UINT8*) fname;

    try {
        gEconLexer::InputStreamType input(fName, ANTLR_ENC_8BIT);
        gEconLexer lxr(&input);   // CLexerNew is generated by ANTLR
        gEconParser::TokenStreamType tstream(ANTLR_SIZE_HINT, lxr.get_tokSource() );
        gEconParser psr(&tstream);   // CParserNew is generated by ANTLR3
        psr.get_state()->set_tokenNames(tnames);
        psr.model();
        free_tnames(tnames);
    }
    catch (std::bad_alloc &ba)
    {
        errors.clear();
        model_obj.clear();
        free_tnames(tnames);
        report_errors(std::string("(gEcon error): out of memory"));
    }
    catch (antlr3::ParseFileAbsentException &pfa)
    {
        errors.clear();
        model_obj.clear();
        free_tnames(tnames);
        report_errors(std::string("(gEcon error): cannot open file \'") +
                      name + "\'");
    }
    catch (std::exception &e) {
        errors.clear();
        model_obj.clear();
        free_tnames(tnames);
#ifdef R_DLL
        report_errors(std::string("(gEcon internal error): this is a bug :-(, please \
report it (with the .gcn file that caused this message) to " + gecon_bug_str()));
#else /* R_DLL */
        report_errors(std::string("(gEcon internal error): ") + e.what());
#endif /* R_DLL */
    }

    if (errors.size()) {
        std::string mes;
        std::vector<std::string>::const_iterator it;
#if defined(NERRTHRESH)
#undef NERRTHRESH
#endif
#define NERRTHRESH 10
        int i = 1, n = errors.size(), nn;
        if (n <= NERRTHRESH) nn = n; else nn = NERRTHRESH - 1;
        for (it = errors.begin(); i <= nn; ++it, ++i) {
            mes += "(gEcon parse error " + num2str(i) + "): " + *it;
            if (i < nn) mes += '\n';
        }
        if (n > NERRTHRESH) {
            mes += "\n(gEcon parse errors): " + num2str(n - NERRTHRESH + 1) + " more follow";
        }
        errors.clear();
        model_obj.clear();
        report_errors(mes);
    }

#ifdef DEBUG
    std::cout << " => Begin parsing the model ..." << std::endl;
#endif
    try {
        model_obj.do_it();
    }
    catch (std::bad_alloc &ba)
    {
        errors.clear();
        model_obj.clear();
        report_errors(std::string("(gEcon error): out of memory"));
    }
    catch (std::runtime_error &e) {
        errors.clear();
        model_obj.clear();
#ifdef R_DLL
        report_errors(std::string("(gEcon internal error): this is a bug :-(, please \
report it (with the .gcn file that caused this message) to " + gecon_bug_str()));
#else /* R_DLL */
        report_errors(std::string("(gEcon internal error): ") + e.what());
#endif /* R_DLL */
    }
    if (model_obj.warnings()) {
        std::string mes(model_obj.get_warns());
        report_warns(mes);
        model_obj.check_warns();
    }
    if (model_obj.errors()) {
        std::string mes(model_obj.get_errs());
        model_obj.clear();
        report_errors(mes);
    }
#ifdef DEBUG
    std::cout << " => Finished!" << std::endl;
#endif
    
    model_obj.write();
    model_obj.clear();
}
